/*-
 * Copyright (c) 2016-present Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <cctype>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <system_error>

#include <unistd.h>

#include "generate.h"
#include "parser.h"
#include "utils.h"

using namespace oncrpc::rpcgen;
using namespace std;

[[noreturn]] void usage()
{
    cerr << "usage: rpcgen [-t] [-x] [-i] [-c] [-n namespace] file.x" << endl;
    exit(1);
}

int
main(int argc, char* const argv[])
{
    bool generateTypes = false;
    bool generateXdr = false;
    bool generateInterface = false;
    bool generateClient = false;
    bool generateServer = false;
    vector<string> namespaces;
    int opt;

    while ((opt = getopt(argc, argv, "txicsn:")) != -1) {
        switch (opt) {
        case 't':
            generateTypes = true;
            break;

        case 'x':
            generateXdr = true;
            break;

        case 'i':
            generateInterface = true;
            break;

        case 'c':
            generateClient = true;
            break;

        case 's':
            generateServer = true;
            break;

        case 'n':
            try {
                namespaces = parseNamespaces(optarg);
            }
            catch (runtime_error& e) {
                cerr << e.what() << endl;
                return 1;
            }
            break;

        case '?':
        default:
            usage();
        }
    }
    argc -= optind;
    argv += optind;

    if (!(generateTypes || generateXdr || generateInterface || generateClient))
        usage();

    if (argc != 1)
        usage();
    ifstream file(argv[0]);
    if (!file.is_open()) {
        error_code ec(errno, system_category());
        cerr << "rpcgen: " << argv[0] << ": " << ec.message() << endl;
        return 1;
    }

    ostream& str = cout;

    Parser parser(argv[0], file, str);
    try {
        auto spec = parser.parse();

        str << "// Please do not edit this file." << endl;
        str << "// It was generated using rpcgen." << endl;
        str << endl;
        str << "#pragma once" << endl;
        str << endl;
        str << "#include <array>" << endl;
        str << "#include <cstdint>" << endl;
        str << "#include <string>" << endl;
        str << "#include <vector>" << endl;
        str << "#include <rpc++/xdr.h>" << endl;
        if (generateClient) {
            str << "#include <rpc++/channel.h>" << endl;
            str << "#include <rpc++/client.h>" << endl;
        }
        if (generateServer) {
            str << "#include <rpc++/server.h>" << endl;
        }

        for (const auto& ns: namespaces)
            str << "namespace " << ns << " {" << endl;

        str << endl;

        if (generateTypes) {
            GenerateTypes gen(str);
            spec->visit(&gen);
        }
        if (generateXdr) {
            GenerateXdr gen(str);
            spec->visit(&gen);
        }
        if (generateInterface) {
            GenerateInterface gen(str);
            spec->visit(&gen);
        }
        if (generateClient) {
            GenerateClient gen(str);
            spec->visit(&gen);
        }
        if (generateServer) {
            GenerateServer gen(str);
            spec->visit(&gen);
        }

        for (const auto& ns: namespaces)
            str << "} // " << ns << endl;
    }
    catch (runtime_error& e)
    {
        cerr << e.what() << endl;
        exit(1);
    }

    return 0;
}
